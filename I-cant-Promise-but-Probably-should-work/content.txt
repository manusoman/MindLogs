>>>title:::
I can’t Promise, but Probably should work.

>>>publish:::
June 4, 2021

>>>readLength:::
10 minutes read

>>>tags:::
javascript, programming

>>>p:::
Hey folks!

Have you ever used something without understanding how it works?
- Then raise your right leg up (go ahead, do it really).
- Then raise your left leg up.
- Catch yourself if you fall down.
- Finally, continue reading the rest of this article.

Sounds familiar? Yup, JavaScript Promises.

>>>----:::
>>>p:::

I had some difficulty in understanding and using JavaScript Promise when it first appeared. Later I got comfortable using it, although the understanding was still missing. So, in an attempt to bring understanding, I tried to recreate the core functionality of Promise from scratch. It came out well and I realized that Promise was not all that hard!

I still like the good old callback functions by the way… Well, kind of… I don’t know... Whatever...

Just a side note: This is not an article about how exactly Promise works. Rather, this is an attempt to write asynchronous code in a synchronous way - just like Promise. Yet, doing so might make Promise clearer to you.

Let’s first look at how we use a <span class="codeWord">Promise</span> first.

>>>code:::language-javascript:::
    // Create a Promise
    const task = new Promise((resolve, reject) => {

        // Use setTimeout to create asynchronicity
        setTimeout(() => {

            // Choose 0 or 1 randomly
            const flag = Math.round(Math.random());

            // Invoke resolve or reject handlers based on flag
            flag ? resolve('Success!') : reject(new Error('Oops!'));

        }, 1000);
    });


    // Add custom resolve and reject handlers
    task.then(console.log)
    .catch(console.error)
    .finally(() => console.log('Meh...'));

>>>p:::
A new <span class="codeWord">Promise</span> is created and passed in the executor function. I used <span class="codeWord">setTimout</span> to create an asynchronous operation and then called the <span class="codeWord">resolve</span>/<span class="codeWord">reject</span> handlers based on the value of the <span class="codeWord">flag</span> variable.

Wait a second... Are <span class="codeWord">const</span> variables variables? They can’t vary!

Next, the <span class="codeWord">then</span>, <span class="codeWord">catch</span> and <span class="codeWord">finally</span> methods are used to pass in the <span class="codeWord">resolve</span>, <span class="codeWord">reject</span> and "<span class="codeWord">finally</span>" handlers (I call it <span class="codeWord">endTask</span>) to the <span class="codeWord">Promise</span>. Those will be executed accordingly once the asynchronous executor finishes its job. This is the core of a JavaScript Promise.

>>>h2:::
Now, how can we do this ourselves, Probably?

>>>p:::
Let’s start with a question. In the previous example, the executor function will be executed immediately after the <span class="codeWord">Promise</span> is created (that’s the requirement). But how does that work since we haven’t provided those <span class="codeWord">resolve</span> and <span class="codeWord">reject</span> parameters yet?!

Simple. Just create default <span class="codeWord">resolve</span> and <span class="codeWord">reject</span> handlers and pass them on to the executor. Once the executor is run and produces an output (or error) the default handlers should store them on the object. Whenever the user sets their own <span class="codeWord">resolve</span> and <span class="codeWord">reject</span> handlers, simply call those with the stored output. Ta-da… Just as Promised! This resolved the mystery of Promise for me.

Alright then, let’s recreate this baby (no, that’s not what I meant). But what do we name him? ...her? Anyway, I’m very modest about my programming skills. Hence, it’s not wise for me to Promise or Ensure or Guarantee or Swear or anything. Instead, I name it <strong>Probably</strong>. Yes, I just used an adverb as noun, because now I can cleverly say,

"Oh yeah... This Probably should work!"

Let’s jump into the code, the Probably constructor first. I still use the old-style function constructors to create objects (perhaps I’m not class-y). We won’t be doing error handling and other checks here in order to simplify the code (who’d wanna do error handling anyway? Such a waste of time...).

>>>----:::